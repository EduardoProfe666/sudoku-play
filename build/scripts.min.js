// ---------------------------------------------- Main Engine Generator v3 ------------------------------------------------- //
// ------------- Constants ---------------- //
const SEEDS = [
    {
        puzzle: 'g--d--caf---g----ii-f--hg-bb-iaedhgc--afcg--d-g-b-----f-d--abc---b------c--h-bfia',
        solution: 'gbhdiecafacegbfdhiidfcahgebbfiaedhgcehafcgibddgcbhiafefidegabchhabifcedgceghdbfia',
        difficulty: 'easy',
    },
    {
        puzzle: 'bf-hiac-g-gi------a-hf-g---g-a-fi--ddef---i-b--b-a-g-ff---gbh--hac---------e-cfd-',
        solution: 'bfdhiacegegicbdafhachfegdbighabfiecddefgchiabcibdaeghffdeagbhichacidfbgeibgehcfda',
        difficulty: 'easy',
    },
    {
        puzzle: 'hgad-e--b-cbf-ge---df-aih-----i-------d-ecai-g---fa----igadf----fe-i-----h-eg-fd-',
        solution: 'hgadceifbicbfhgeadedfbaihcgcahibdgeffbdgecaihgeihfadbcbigadfchedfecihbgaahcegbfdi',
        difficulty: 'easy',
    },
    {
        puzzle: '-fbe-c----e-----a---g-ihb--gb-fhdc-eid-g-eahbch-----f-----ef-ga-g----e-i--hi-----',
        solution: 'afbegcidhheidfbgacdcgaihbefgbafhdcieidfgceahbchebaidfgbidcefhgafgchdaebieahibgfcd',
        difficulty: 'easy',
    },
    {
        puzzle: 'c--d-fgeb---g--i-hg-ih--da-a-g-b-cde-edc--a--b--------i-e-cd-ha-fb-h-e-ch--e-----',
        solution: 'cahdifgebedfgabichgbihecdafahgfbicdefedcghabibicadehfgigebcdfhadfbihaegchcaefgbid',
        difficulty: 'easy',
    },
    {
        puzzle: 'bi---ec--eg--h-fbdf--------i-hba-dfe----ehbig--bf-d-h--f-e-a-c-----g-e--cde--f--a',
        solution: 'bidgfecahegcahifbdfhadcbgeiichbagdfedafcehbiggebfidahchfgedaicbabihgcedfcdeibfhga',
        difficulty: 'easy',
    },
    {
        puzzle: '-----ef-ha--bf--ecfe-gc---a----gbch--a--df-b--bi----f-h-af-gidbdf----g--i--c--ha-',
        solution: 'bicdaefghahgbfidecfedgchbiaedfagbchicahidfebggbiehcafdhcafegidbdfbhiagceigecbdhaf',
        difficulty: 'easy',
    },
    {
        puzzle: '--fg--hec-ebc-------h-dfgabb--h-a-fg-g-df-i--f-a---b--hf----ad---if----hc-ea---bi',
        solution: 'dafgbihecgebcahdifichedfgabbidhcaefgegcdfbihafhaigebcdhfgbicadeabifedcghcdeahgfbi',
        difficulty: 'easy',
    },
    {
        puzzle: '-----b-f-e-aih----bi----a----e---i---g-bf--a-----cihg-ic-fdhg-a--h---f-cgef-iad-b',
        solution: 'dhcgabefiefaihcbdgbigdefachcaehgdibfhgibfecadfbdacihgeicbfdhgeaadhebgficgefciadhb',
        difficulty: 'easy',
    },
    {
        puzzle: 'e--f-b-------eid-f--h----b-ge-c-fadhab-ihgfe-hc--d----d-g---cf---eg--h-bf---i----',
        solution: 'edcfgbihabgaheidcfifhdcaebggeicbfadhabdihgfechcfadebgidigbahcfecaegfdhibfhbeicgad',
        difficulty: 'easy',
    },
    {
        puzzle: 'g-hedcf---i-f--a--e--a-----c--i-deh-i-------g--g--e---a----f--c-cf-e-gi-b-------e',
        solution: 'gahedcfbidicfbgaehefbaihcgdcbaigdehfihebfadcgfdghceiabaeighfbdchcfdebgiabgdcaihfe',
        difficulty: 'medium',
    },
    {
        puzzle: '-di--ac---b-cid-h---h--b-d-----f----h-d----fca---c-i--d----i-e-bh---cd-g-g---fac-',
        solution: 'fdighacbeebgcidfhacahfebgdigecifhbadhidabgefcafbdceighdcabgihefbhfeacdigigehdfacb',
        difficulty: 'medium',
    },
    {
        puzzle: '--ac-i------ah-d---e----i---a-e-bc----g--f--ad---gae--ig-fa------hd-e-g-c-d-b----',
        solution: 'hdaceigfbbifahgdcegecbfdiahfaiedbchgehgicfbdadcbhgaeifigefachbdabhdiefgccfdgbhaei',
        difficulty: 'medium',
    },
    {
        puzzle: 'fg----i---h--f-e--e-bd--afh-f--hg--ic------b----f-c-----c-------eiac-gdf-b-----e-',
        solution: 'fgaebhicdihdcfaegbecbdgiafhdfebhgcaicahidefbgbigfacdhegdchefbiaheiacbgdfabfgidhec',
        difficulty: 'medium',
    },
    {
        puzzle: '--d-g-fi---e-ci-d-a----eg-----i---f---bg--ec-e--d--haig----f----ha--------ch-g-e-',
        solution: 'cbdaghfiehgefciadbaifbdeghcdahiecbfgifbghaecdecgdfbhaigeicafdbhbhaeidcgffdchbgiea',
        difficulty: 'medium',
    },
    {
        puzzle: '----d-a---a-ie---di------h-d-e--cg-b-b-e--i----c-i--dh--h-gf--c------b-g--i-ce-a-',
        solution: 'ehfcdgabicabiehfgdigdfbachediehacgfbhbgefdicaafcgibedhbehagfdicfcadhibeggdibcehaf',
        difficulty: 'medium',
    },
    {
        puzzle: '---cfa-ibf---i-------g---f--i--h-cd-gdf--------cd--fb-------bc--gb---dhi---he--g-',
        solution: 'dhecfagibfbgeidhaccaigbhefdbiafhecdggdfbaciehhecdgifbaafhidgbceegbacfdhiicdhebagf',
        difficulty: 'medium',
    },
    {
        puzzle: 'a------g-b--di-a-f--e--ahi----a------bae--------ichbaei---de------c-igd-d-h----ci',
        solution: 'aidhefcgbbhgdicaeffcebgahidheiabgdfccbaefdihggdfichbaeiacgdefbhefbchigdadghfabeci',
        difficulty: 'medium',
    },
    {
        puzzle: '----g-------ci--bg-i-de-af-------beh-----fgdi---eb-f----ah--ig---hg-d---cd--a----',
        solution: 'hacfgbdieefdciahbggibdehafcagfidcbehbceahfgdidhiebgfcafbahceigdiehgfdcabcdgbaiehf',
        difficulty: 'medium',
    },
    {
        puzzle: 'gfbc---dh-a-------d--a--fi--daifc--ech------f-------c-f---e--b---d-----i--igh-d--',
        solution: 'gfbcieadhiahbdfcegdceaghfibbdaifcghechgebdiafeifhagbcdfgcdeihbahbdfcaegiaeighbdfc',
        difficulty: 'medium',
    },
    {
        puzzle: '-e-fh--a-g----ed---a--b-f---ih----dc--------a----g----b---i---dhc-gf-----g------e',
        solution: 'debfhciagghfiaedcbcaidbgfehaihbefgdcfbgcdiehaedchgabifbfaeihcgdhcegfdabiigdacbhfe',
        difficulty: 'hard',
    },
    {
        puzzle: '----i-b---fc--a-h-eb----i-fcieg--ad---hd-e----d--a----f---b-e-i-------b--h--e----',
        solution: 'hageifbcdifcbdagheebdchgiafciegfbadhaghdcefibbdfiahcegfcahbdegideifgchbaghbaeidfc',
        difficulty: 'hard',
    },
    {
        puzzle: '-------hg-----h-d-a-g---ei--ce--dg--dbf---------bfid--hg---f----d--h---c--a-eg---',
        solution: 'bedfiachgficeghbdaahgdbceificehadgfbdbfgceiahgahbfidcehgbcdfaeiediahbfgccfaieghbd',
        difficulty: 'hard',
    },
    {
        puzzle: 'h---f------------i--e---a-h-dhe---a---fh-b----i--c---gf-ga-di--a-i---d-bce------a',
        solution: 'hgcifabdedabgehfciifebdcaghbdheigcafgcfhabeideiadcfhbgfbgahdiecahicgedfbcedfbigha',
        difficulty: 'hard',
    },
    {
        puzzle: 'f----dha----b------a------dic---h------c--egb-----------a-----ed--f-ec-g-fg------',
        solution: 'febigdhachdcbfageigaiehcbfdicegbhadfahfcdiegbbgdaefichcbadigfhedihfaecbgefghcbdia',
        difficulty: 'hard',
    },
    {
        puzzle: 'c-a---i---b--c--ede----g--c-e---dga--c---b--i--gf-----b-----ei------a-cg--ie----a',
        solution: 'cfahdeigbgbhacifedeidbfgahchebcidgafacfgebhdiidgfahcbebacdgfeihfheibadcgdgiehcbfa',
        difficulty: 'hard',
    },
    {
        puzzle: '--a-i---cc-g-------h--e--a--a---ib---d--f--h-----------i---d-f------g-c-dg---b--h',
        solution: 'beagifhdccfghdaibeihdbecfaghafcgibedgdbafechiecidbhagfaihecdgfbfbeihgdcadgcfabeih',
        difficulty: 'hard',
    },
    {
        puzzle: 'i--f--ec------a-fbg-b-i---h-d---ihg-----b---fe---a------d-----i---ie-b-------g---',
        solution: 'iahfdbecgdcehgaifbgfbeicdahbdacfihgechgdbeaifeifgahcbdhbdacfgeifgciedbhaaeibhgfdc',
        difficulty: 'hard',
    },
    {
        puzzle: '--e---c------i--g-------d-hbaf--------cfhe--ie------f-h-d-c-----f-h----c---i-ga--',
        solution: 'fdegbhciaacheidfgbibgcfadehbafdgihcedgcfhebaiehibacgfdhidacfebggfahebidccebidgahf',
        difficulty: 'hard',
    },
    {
        puzzle: '--f-d-i---g--b-a-d--c-a-----c-i---e---eh--g---------ac---------b---i-e----gf--d--',
        solution: 'abfcdhigehgiebfacddecgaibhfgcdifahebfaehcbgdiihbdegfacefabgdcihbdhaicefgcigfhedba',
        difficulty: 'hard',
    },
    {
        puzzle: '-ica------------bh----g--f--g---a---i-e----c-a---f------d--bg------c---e-fg----id',
        solution: 'ficabhdeggeaidfcbhdhbegcifabgfceahdiidebhgacfachdfiegbeadfibghchbigcdfaecfghaebid',
        difficulty: 'expert',
    },
    {
        puzzle: '-h-i------i---------f--bh--b---a--ed-ca------i--f---h--------c----he--f-ab--df---',
        solution: 'ehbicdgafdigafhcbecafegbhdibghcaifedfcadheigbiedfbgahchfebiadcggdihecbfaabcgdfeih',
        difficulty: 'expert',
    },
    {
        puzzle: '-h--c-f-ice-------b--ia--------g-h------e---ff--h---i----b---eh----------ga--f--c',
        solution: 'ahgdcefbiceigfbahdbfdiahcgediefgchabgbhaeidcffachbdeigicfbdagehedbchgifahgaeifbdc',
        difficulty: 'expert',
    },
    {
        puzzle: 'a----db---g-c----f--e-f--i---------i----h-f-d--g---ch---b--e-c-ca------h-d-------',
        solution: 'afchidbegigdcebhafhbegfadicfehdgcabibcaehifgddigbafcheghbfdeicacafibgedhediachgfb',
        difficulty: 'expert',
    },
    {
        puzzle: '------c--g-b--a---------g-h---e----gb--id-----i-f---eb----i---c-he-f-d--a------h-',
        solution: 'edhbgicfagfbchaeidicadefgbhhafebcidgbegidhacfdicfaghebfgdhiebaccheafbdgiabigcdfhe',
        difficulty: 'expert',
    },
    {
        puzzle: '---bf-i-------hc-aa----------g------h--c-e----i----bh----f---g--f-----e---hig-a--',
        solution: 'chebfaidgfgdeihcbaabidcgefhbeghdifachafcbegiddicgafbheicafedhgbgfbahcdeiedhigbacf',
        difficulty: 'expert',
    },
    {
        puzzle: '--c-----d---g-i--h-i----b--ace------d--bh----b--f---------e---------bea--d--a--c-',
        solution: 'gecabhifdfbagdicehhidefcbgaaceigdhbfdgfbheaicbhifcagdeiagcefdhbcfhdibeagedbhagfci',
        difficulty: 'expert',
    },
    {
        puzzle: '-----d-h--h-----a-gb------i-----a--g----eh-c--i--d-----ge---a--d----f-----ab--i--',
        solution: 'iacefdghbehdgibcafgbfhacedicehfbadigfdgiehbcaaibcdgfehbgedhiafcdciagfhbehfabceigd',
        difficulty: 'expert',
    },
    {
        puzzle: '-bi-------c----e---------af---eba-----a-i-g------c--i----h-e--d-e------gc-b--f---',
        solution: 'fbiaegdhcachdfbegiedgchibafgicebafdhbhafidgcedfegchaibiafhgecbdhedbacifgcgbidfhea',
        difficulty: 'expert',
    },
    {
        puzzle: '---i--h-bc----b----g----a----gd-----e--h-f------b---ac-c------ha-----id--i--gd---',
        solution: 'deficahgbchagfbdeibgiedhacffagdicbheebchafgididhbegfacgcdabiefhafbcheidghiefgdcba',
        difficulty: 'expert',
    },
];
const BASE_LAYOUT = [
    [0, 1, 2, 3, 4, 5, 6, 7, 8],
    [9, 10, 11, 12, 13, 14, 15, 16, 17],
    [18, 19, 20, 21, 22, 23, 24, 25, 26],
    [27, 28, 29, 30, 31, 32, 33, 34, 35],
    [36, 37, 38, 39, 40, 41, 42, 43, 44],
    [45, 46, 47, 48, 49, 50, 51, 52, 53],
    [54, 55, 56, 57, 58, 59, 60, 61, 62],
    [63, 64, 65, 66, 67, 68, 69, 70, 71],
    [72, 73, 74, 75, 76, 77, 78, 79, 80],
];

// ------------- Helper ----------------- //
const boardToSequence = (board) => board.map((row) => row.join('')).join('');
const getRandomItem = (items) => items[Math.floor(Math.random() * items.length)];
const getSequence = (layout, seedSequence, tokenMap) => boardToSequence(populateLayout(layout, replaceTokens(seedSequence, tokenMap)));
const replaceTokens = (sequence, tokenMap) => sequence.split('').map((token) => tokenMap[token] || token).join('');
const sortRandom = () => (Math.random() < 0.5 ? 1 : -1);


// -------------- Layout ---------------- //
const getLayout = (baseLayout) => shuffleLayout(rotateLayout(baseLayout));
const getLayoutBands = (layout) => [
    [layout[0], layout[1], layout[2]],
    [layout[3], layout[4], layout[5]],
    [layout[6], layout[7], layout[8]],
];
const populateLayout = (layout, sequence) => layout.map((row) => row.map((cell) => sequence[cell]));
const rotateLayout = (layout) => getRandomItem([rotateLayout0, rotateLayout90, rotateLayout180, rotateLayout270])(layout);
const rotateLayout0 = (layout) => layout;
const rotateLayout90 = (layout) => layout[0].map((_row, index) => layout.map((row) => row[index]).reverse());
const rotateLayout180 = (layout) => layout.map((row) => [...row].reverse()).reverse();
const rotateLayout270 = (layout) => layout[0].map((_row, index) => layout.map((row) => [...row].reverse()[index]));
const shuffleLayout = (layout) => shuffleLayoutColumns(shuffleLayoutRows(shuffleLayoutStacks(shuffleLayoutBands(layout))));
const shuffleLayoutBands = (layout) => getLayoutBands(layout).sort(sortRandom).flat();
const shuffleLayoutColumns = (layout) => rotateLayout270(shuffleLayoutRows(rotateLayout90(layout)));
const shuffleLayoutRows = (layout) => getLayoutBands(layout)
    .map((rows) => rows.sort(sortRandom))
    .flat();
const shuffleLayoutStacks = (layout) =>
    rotateLayout270(shuffleLayoutBands(rotateLayout90(layout)));

// --------------- Seed ------------------ //
const getSeedsByDifficulty = (seeds, difficulty) => seeds.filter((seed) => !difficulty || seed.difficulty === difficulty);
const getSeed = (seeds, difficulty) => getRandomItem(getSeedsByDifficulty(seeds, difficulty));

// ----------------- Token --------------- //
const getTokenMap = () =>
    'abcdefghi'
        .split('')
        .sort(sortRandom)
        .reduce(
            (acc, token, index) => ({
                ...acc,
                [token]: String(index + 1),
            }),
            {},
        )

// ------------------- Convert Sudoku String to Sudoku Array ------------------------- //
function convertSudokuStringToArray(sudokuString) {
    const sudokuArray = Array.from({ length: 9 }, () => Array(9).fill(0));

    for (let i = 0; i < sudokuString.length; i++) {
        const row = Math.floor(i / 9);
        const col = i % 9;
        const char = sudokuString[i];

        if (char >= '1' && char <= '9') {
            sudokuArray[row][col] = parseInt(char, 10);
        }
    }

    return sudokuArray;
}

// ------------------ Generate Sudoku with seed fast transformations algorithm ----------------- //
function getSudoku(difficulty){
    const seed = getSeed(SEEDS, difficulty);
    const layout = getLayout(BASE_LAYOUT);
    const tokenMap = getTokenMap();

    const puzzle = convertSudokuStringToArray(getSequence(layout, seed.puzzle, tokenMap));
    const solution = convertSudokuStringToArray(getSequence(layout, seed.solution, tokenMap));

    return {
        puzzle,
        solution,
        difficulty: seed.difficulty,
    };
}

// --------------- Sudoku Generation with Levels of Difficulty -------------- //
function generateSudoku(difficulty, numbers = initialNumbers) {

    let dif;

    switch (difficulty) {
        case 1:
            dif = 'easy';
            break;
        case 2:
            dif = 'medium';
            break;
        case 3:
            dif = 'hard';
            break;
        case 4:
            dif = 'expert';
            break;
        case 5:
            dif = 'expert';
            break;
        default:
            dif = 'medium'; // Medium by default
            break;
    }

    const sudoku = getSudoku(dif);

    for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
            numbers[row][col] = sudoku.puzzle[row][col];
        }
    }

    for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
            solution[row][col] = sudoku.solution[row][col];
        }
    }

}

// ---------------------------------------------- Main Engine Solver v3 ------------------------------------------------- //
// ------------- Common Stuff ---------------- //
function isValidSudoku(board) {
    for (let row = 0; row < 9; row++) {
        if (!isValidGroup(board[row])) return false;
    }

    for (let col = 0; col < 9; col++) {
        const column = board.map(row => row[col]);
        if (!isValidGroup(column)) return false;
    }

    for (let row = 0; row < 9; row += 3) {
        for (let col = 0; col < 9; col += 3) {
            const subgrid = [];
            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                    subgrid.push(board[row + r][col + c]);
                }
            }
            if (!isValidGroup(subgrid)) return false;
        }
    }

    return true;
}

function isValidGroup(group) {
    const seen = new Set();
    for (let i = 0; i < group.length; i++) {
        if (group[i] !== 0) {
            if (seen.has(group[i])) return false;
            seen.add(group[i]);
        }
    }
    return true;
}

function countClues(board) {
    let clueCount = 0;

    for (let row = 0; row < board.length; row++) {
        for (let col = 0; col < board[row].length; col++) {
            if (board[row][col] !== 0) {
                clueCount++;
            }
        }
    }

    return clueCount;
}

function hasAtLeast17Clues(board) {
    return countClues(board) >= 17;
}


// --------------- Solve Sudoku - Manual Fill ------------------ //
function solveSudoku(board) {
    const size = 9;

    function isValid(board, row, col, num) {
        for (let x = 0; x < size; x++) {
            if (board[row][x] === num || board[x][col] === num) {
                return false;
            }
        }

        const startRow = Math.floor(row / 3) * 3;
        const startCol = Math.floor(col / 3) * 3;

        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                if (board[startRow + i][startCol + j] === num) {
                    return false;
                }
            }
        }

        return true;
    }

    function solve() {
        for (let row = 0; row < size; row++) {
            for (let col = 0; col < size; col++) {
                if (board[row][col] === 0) {
                    for (let num = 1; num <= size; num++) {
                        if (isValid(board, row, col, num)) {
                            board[row][col] = num;
                            if (solve()) {
                                return true;
                            }
                            board[row][col] = 0;
                        }
                    }
                    return false;
                }
            }
        }
        return true;
    }

    if (solve()) {
        return board;
    } else {
        return null;
    }
}

// ------------- Sudoku Solvable? - Manual Fill -------------- //
function isSudokuSolvable(grid){
    return isValidSudoku(grid.map(row => [...row])) && hasAtLeast17Clues(grid.map(row => [...row]));
}


// --------------------- Sudoku Solved? ----------------- //
function isSudokuSolved(grid) {
    const flatGrid = grid.flat();
    const flatSolution = solution.flat();
    return flatGrid.every((value, index) => parseInt(value) === parseInt(flatSolution[index]));
}

const translations = {
    en: {
        title: "Sudoku Play",
        message: "Choose the game's fill mode",
        autoFillButton: "<i class='fas fa-magic'></i> Auto Fill",
        manualFillButton: "<i class='fas fa-pencil-alt'></i> Manual Fill",
        timer: "Elapsed Time: ",
        surrender: "Surrender",
        help: "Help",
        close: "Close",
        gameOverTitle: "‚ò†Ô∏è Game Over ‚ò†Ô∏è",
        gameOverText: "Elapsed Time: ",
        gameOverFillMode: "Fill Mode: ",
        gameOverDifficulty: "Difficulty: ",
        winningTitle: "üéâ You Win! üéâ",
        winningText: "Elapsed Time: ",
        winningFillMode: "Fill Mode: ",
        winningDifficulty: "Difficulty: ",
        restartGame: "<i class='fas fa-redo'></i> Restart Game",
        language: "Language",
        selectLanguage: "Select Language",
        helpTitle: "Sudoku Help",
        helpBasicRules: "Basic Rules of Sudoku",
        rule1: "Each <strong>row</strong> must contain the numbers from <strong>1</strong> to <strong>9</strong>, without repetitions.",
        rule2: "Each <strong>column</strong> must contain the numbers from <strong>1</strong> to <strong>9</strong>, without repetitions.",
        rule3: "Each <strong>block</strong> must contain the numbers from <strong>1</strong> to <strong>9</strong>, without repetitions.",
        rule4: "The sum of all numbers in any complete <strong>row</strong>, <strong>column</strong>, or <strong>block</strong> is always <strong>45</strong>.",
        helpAssistanceTypes: "Assistance Types",
        helpRemainingNumbersDock: "<strong>Remaining Numbers Dock:</strong> Indicates required grid numbers, highlighting used digits. Exhausted numbers are marked, and overlimit digits turn red.",
        helpNotes: "<strong>Notes:</strong> Allows you to take notes on possible numbers for each cell. Double touch in a cell if you are in mobile, or right click if you are in desktop",
        helpConflicts: "<strong>Conflicts:</strong> Highlights cells that contain numbers causing conflicts in their row, column, or block.",
        surrenderTitle: "Are you sure?",
        surrenderText: "You won't be able to revert this!",
        surrenderConfirm: "Yes, surrender!",
        surrenderCancel: "No, cancel!",
        manualFillTitle: "Fill the initial numbers",
        startGame: "Start Game",
        manualLinkTitle: "Human Solvable Sudoku Article",
        manualValidation: "Given sudoku must be human solvable (at least 17 clues) and must obey sudoku rules.",
        autoFillTitle: "Choose the game\'s difficulty",
        autoValidation: 'You must select a difficulty',
        easy: 'Easy',
        medium: 'Medium',
        hard: 'Hard',
        expert: 'Expert',
        insane: 'Insane',
        autoName: 'Name',
        autoLevel: 'Level of Generated Puzzle',
        autoQuantityErrors: 'Quantity of possible errors to commit',
        autoAssistance1: 'Assistance and Help',
        autoAssistance2: 'No Assistance nor Help',
        autoConceptError1: 'The concept errors are count as errors to commit',
        autoConceptError2: 'The concept errors',
        autoConceptError3: 'The concept errors aren\'t count as errors to commit',
        auto: "Automatic",
        manual: "Manual"
    },
    es: {
        title: "Juego del Sudoku",
        message: "Elige el modo de relleno del juego",
        autoFillButton: "<i class='fas fa-magic'></i> Relleno Autom√°tico",
        manualFillButton: "<i class='fas fa-pencil-alt'></i> Relleno Manual",
        timer: "Tiempo Transcurrido: ",
        surrender: "Rendirse",
        help: "Ayuda",
        close: "Cerrar",
        gameOverTitle: "‚ò†Ô∏è Fin del Juego ‚ò†Ô∏è",
        gameOverText: "Tiempo Transcurrido: ",
        gameOverFillMode: "Modo de Relleno: ",
        gameOverDifficulty: "Dificultad: ",
        winningTitle: "üéâ ¬°Ganaste! üéâ",
        winningText: "Tiempo Transcurrido: ",
        winningFillMode: "Modo de Relleno: ",
        winningDifficulty: "Dificultad: ",
        restartGame: "<i class='fas fa-redo'></i> Reiniciar Juego",
        language: "Idioma",
        selectLanguage: "Seleccionar Idioma",
        helpTitle: "Ayuda de Sudoku",
        helpBasicRules: "Reglas B√°sicas del Sudoku",
        rule1: "Cada <strong>fila</strong> debe contener los n√∫meros del <strong>1</strong> al <strong>9</strong>, sin repeticiones.",
        rule2: "Cada <strong>columna</strong> debe contener los n√∫meros del <strong>1</strong> al <strong>9</strong>, sin repeticiones.",
        rule3: "Cada <strong>bloque</strong> debe contener los n√∫meros del <strong>1</strong> al <strong>9</strong>, sin repeticiones.",
        rule4: "La suma de todos los n√∫meros en cualquier <strong>fila</strong>, <strong>columna</strong> o <strong>bloque</strong> completo siempre es <strong>45</strong>.",
        helpAssistanceTypes: "Tipos de Asistencia",
        helpRemainingNumbersDock: "<strong>Dock de N√∫meros Restantes:</strong> Indica los n√∫meros requeridos en la cuadr√≠cula, resaltando los d√≠gitos utilizados. Los n√∫meros agotados est√°n marcados y los d√≠gitos en exceso se vuelven rojos.",
        helpNotes: "<strong>Notas:</strong> Te permite tomar notas sobre los posibles n√∫meros para cada celda. Doble toque si est√°s en el tel√©fono, o clic derecho si est√°n en una PC.",
        helpConflicts: "<strong>Conflictos:</strong> Resalta las celdas que contienen n√∫meros causando conflictos en su fila, columna o bloque.",
        surrenderTitle: "¬øEst√°s seguro?",
        surrenderText: "¬°No podr√°s revertir esto!",
        surrenderConfirm: "S√≠, rendirse!",
        surrenderCancel: "No, cancelar!",
        manualFillTitle: "Rellena los n√∫meros iniciales",
        startGame: "Iniciar Juego",
        manualLinkTitle: "Art√≠culo sobre Sudoku Soluble por Humanos",
        manualValidation: "El sudoku dado debe ser soluble por humanos (al menos 17 pistas) y debe obedecer las reglas del sudoku.",
        autoFillTitle: "Elige la dificultad del juego",
        autoValidation: "Debes seleccionar una dificultad",
        easy: "F√°cil",
        medium: "Medio",
        hard: "Dif√≠cil",
        expert: "Experto",
        insane: "Insano",
        autoName: "Nombre",
        autoLevel: "Nivel del rompecabezas generado",
        autoQuantityErrors: "Cantidad de errores posibles a cometer",
        autoAssistance1: "Asistencia y Ayuda",
        autoAssistance2: "Sin Asistencia ni Ayuda",
        autoConceptError1: "Los errores de concepto se cuentan como errores a cometer",
        autoConceptError2: "Los errores de concepto (no) se cuentan como errores a cometer",
        autoConceptError3: "Los errores de concepto no se cuentan como errores a cometer",
        auto: "Autom√°tico",
        manual: "Manual",
    },
    fr: {
        title: "Jeu de Sudoku",
        message: "Choisissez le mode de remplissage du jeu",
        autoFillButton: "<i class='fas fa-magic'></i> Remplissage Automatique",
        manualFillButton: "<i class='fas fa-pencil-alt'></i> Remplissage Manuel",
        timer: "Temps √©coul√©: ",
        surrender: "Abandonner",
        help: "Aide",
        close: "Fermer",
        gameOverTitle: "‚ò†Ô∏è Fin de la Partie ‚ò†Ô∏è",
        gameOverText: "Temps √©coul√©: ",
        gameOverFillMode: "Mode de Remplissage: ",
        gameOverDifficulty: "Difficult√©: ",
        winningTitle: "üéâ Vous avez gagn√©! üéâ",
        winningText: "Temps √©coul√©: ",
        winningFillMode: "Mode de Remplissage: ",
        winningDifficulty: "Difficult√©: ",
        restartGame: "<i class='fas fa-redo'></i> Recommencer le Jeu",
        language: "Langue",
        selectLanguage: "S√©lectionner la Langue",
        helpTitle: "Aide de Sudoku",
        helpBasicRules: "R√®gles de Base du Sudoku",
        rule1: "Chaque <strong>ligne</strong> doit contenir les nombres de <strong>1</strong> √† <strong>9</strong>, sans r√©p√©titions.",
        rule2: "Chaque <strong>colonne</strong> doit contenir les nombres de <strong>1</strong> √† <strong>9</strong>, sans r√©p√©titions.",
        rule3: "Chaque <strong>bloc</strong> doit contenir les nombres de <strong>1</strong> √† <strong>9</strong>, sans r√©p√©titions.",
        rule4: "La somme de tous les nombres dans n'importe quelle <strong>ligne</strong>, <strong>colonne</strong> ou <strong>bloc</strong> complet est toujours <strong>45</strong>.",
        helpAssistanceTypes: "Types d'Assistance",
        helpRemainingNumbersDock: "<strong>Dock des Nombres Restants:</strong> Indique les nombres requis dans la grille, en surlignant les chiffres utilis√©s. Les nombres √©puis√©s sont marqu√©s et les chiffres en exc√®s deviennent rouges.",
        helpNotes: "<strong>Notes:</strong> Vous permet de prendre des notes sur les nombres possibles pour chaque cellule.",
        helpConflicts: "<strong>Conflits:</strong> Surbrille les cellules contenant des nombres causant des conflits dans leur ligne, colonne ou bloc.",
        surrenderTitle: "√ätes-vous s√ªr?",
        surrenderText: "Vous ne pourrez pas revenir en arri√®re!",
        surrenderConfirm: "Oui, abandonner!",
        surrenderCancel: "Non, annuler!",
        manualFillTitle: "Remplissez les nombres initiaux",
        startGame: "D√©marrer le Jeu",
        manualLinkTitle: "Article sur le Sudoku Soluble par des Humains",
        manualValidation: "Le sudoku donn√© doit √™tre soluble par des humains (au moins 17 indices) et doit respecter les r√®gles du sudoku.",
        autoFillTitle: "Choisissez la difficult√© du jeu",
        autoValidation: "Vous devez s√©lectionner une difficult√©",
        easy: "Facile",
        medium: "Moyen",
        hard: "Difficile",
        expert: "Expert",
        insane: "Insens√©",
        autoName: "Nom",
        autoLevel: "Niveau du puzzle g√©n√©r√©",
        autoQuantityErrors: "Quantit√© d'erreurs possibles √† commettre",
        autoAssistance1: "Assistance et Aide",
        autoAssistance2: "Aucune Assistance ni Aide",
        autoConceptError1: "Les erreurs de concept sont compt√©es comme des erreurs √† commettre",
        autoConceptError2: "Les erreurs de concept",
        autoConceptError3: "Les erreurs de concept ne sont pas compt√©es comme des erreurs √† commettre",
        auto: "Automatique",
        manual: "Manuel",
    },
    pt: {
        title: "Jogo de Sudoku",
        message: "Escolha o modo de preenchimento do jogo",
        autoFillButton: "<i class='fas fa-magic'></i> Preenchimento Autom√°tico",
        manualFillButton: "<i class='fas fa-pencil-alt'></i> Preenchimento Manual",
        timer: "Tempo Decorrido: ",
        surrender: "Desistir",
        help: "Ajuda",
        close: "Fechar",
        gameOverTitle: "‚ò†Ô∏è Fim de Jogo ‚ò†Ô∏è",
        gameOverText: "Tempo Decorrido: ",
        gameOverFillMode: "Modo de Preenchimento: ",
        gameOverDifficulty: "Dificuldade: ",
        winningTitle: "üéâ Voc√™ Ganhou! üéâ",
        winningText: "Tempo Decorrido: ",
        winningFillMode: "Modo de Preenchimento: ",
        winningDifficulty: "Dificuldade: ",
        restartGame: "<i class='fas fa-redo'></i> Reiniciar Jogo",
        language: "Idioma",
        selectLanguage: "Selecionar Idioma",
        helpTitle: "Ajuda de Sudoku",
        helpBasicRules: "Regras B√°sicas do Sudoku",
        rule1: "Cada <strong>linha</strong> deve conter os n√∫meros de <strong>1</strong> a <strong>9</strong>, sem repeti√ß√µes.",
        rule2: "Cada <strong>coluna</strong> deve conter os n√∫meros de <strong>1</strong> a <strong>9</strong>, sem repeti√ß√µes.",
        rule3: "Cada <strong>bloco</strong> deve conter os n√∫meros de <strong>1</strong> a <strong>9</strong>, sem repeti√ß√µes.",
        rule4: "A soma de todos os n√∫meros em qualquer <strong>linha</strong>, <strong>coluna</strong> ou <strong>bloco</strong> completo √© sempre <strong>45</strong>.",
        helpAssistanceTypes: "Tipos de Assist√™ncia",
        helpRemainingNumbersDock: "<strong>Dock de N√∫meros Restantes:</strong> Indica os n√∫meros necess√°rios na grade, destacando os d√≠gitos usados. N√∫meros esgotados s√£o marcados e d√≠gitos em excesso ficam vermelhos.",
        helpNotes: "<strong>Notas:</strong> Permite que voc√™ fa√ßa anota√ß√µes sobre poss√≠veis n√∫meros para cada c√©lula.",
        helpConflicts: "<strong>Conflitos:</strong> Destaca c√©lulas que cont√™m n√∫meros causando conflitos em sua linha, coluna ou bloco.",
        surrenderTitle: "Tem certeza?",
        surrenderText: "Voc√™ n√£o poder√° reverter isso!",
        surrenderConfirm: "Sim, desistir!",
        surrenderCancel: "N√£o, cancelar!",
        manualFillTitle: "Preencha os n√∫meros iniciais",
        startGame: "Iniciar Jogo",
        manualLinkTitle: "Artigo sobre Sudoku Solucion√°vel por Humanos",
        manualValidation: "O sudoku fornecido deve ser solucion√°vel por humanos (pelo menos 17 pistas) e deve obedecer √†s regras do sudoku.",
        autoFillTitle: "Escolha a dificuldade do jogo",
        autoValidation: "Voc√™ deve selecionar uma dificuldade",
        easy: "F√°cil",
        medium: "M√©dio",
        hard: "Dif√≠cil",
        expert: "Experiente",
        insane: "Insano",
        autoName: "Nome",
        autoLevel: "N√≠vel do Quebra-Cabe√ßa Gerado",
        autoQuantityErrors: "Quantidade de erros poss√≠veis a cometer",
        autoAssistance1: "Assist√™ncia e Ajuda",
        autoAssistance2: "Sem Assist√™ncia nem Ajuda",
        autoConceptError1: "Os erros de conceito s√£o contados como erros a cometer",
        autoConceptError2: "Os erros de conceito",
        autoConceptError3: "Os erros de conceito n√£o s√£o contados como erros a cometer",
        auto: "Autom√°tico",
        manual: "Manual"
    },
    de: {
        title: "Sudoku Spiel",
        message: "W√§hlen Sie den F√ºllmodus des Spiels",
        autoFillButton: "<i class='fas fa-magic'></i> Automatische F√ºllung",
        manualFillButton: "<i class='fas fa-pencil-alt'></i> Manuelle F√ºllung",
        timer: "Verstrichene Zeit: ",
        surrender: "Aufgeben",
        help: "Hilfe",
        close: "Schlie√üen",
        gameOverTitle: "‚ò†Ô∏è Spiel Vorbei ‚ò†Ô∏è",
        gameOverText: "Verstrichene Zeit: ",
        gameOverFillMode: "F√ºllmodus: ",
        gameOverDifficulty: "Schwierigkeit: ",
        winningTitle: "üéâ Sie Haben Gewonnen! üéâ",
        winningText: "Verstrichene Zeit: ",
        winningFillMode: "F√ºllmodus: ",
        winningDifficulty: "Schwierigkeit: ",
        restartGame: "<i class='fas fa-redo'></i> Spiel Neustarten",
        language: "Sprache",
        selectLanguage: "Sprache Ausw√§hlen",
        helpTitle: "Sudoku Hilfe",
        helpBasicRules: "Grundregeln des Sudoku",
        rule1: "Jede <strong>Zeile</strong> muss die Zahlen von <strong>1</strong> bis <strong>9</strong> enthalten, ohne Wiederholungen.",
        rule2: "Jede <strong>Spalte</strong> muss die Zahlen von <strong>1</strong> bis <strong>9</strong> enthalten, ohne Wiederholungen.",
        rule3: "Jedes <strong>Block</strong> muss die Zahlen von <strong>1</strong> bis <strong>9</strong> enthalten, ohne Wiederholungen.",
        rule4: "Die Summe aller Zahlen in jeder vollst√§ndigen <strong>Zeile</strong>, <strong>Spalte</strong> oder <strong>Block</strong> ist immer <strong>45</strong>.",
        helpAssistanceTypes: "Arten der Unterst√ºtzung",
        helpRemainingNumbersDock: "<strong>Dock der Verbleibenden Zahlen:</strong> Zeigt die ben√∂tigten Zahlen im Raster an, wobei verwendete Ziffern hervorgehoben werden. Ausgesch√∂pfte Zahlen sind markiert und √ºberz√§hlige Ziffern werden rot.",
        helpNotes: "<strong>Notizen:</strong> Erm√∂glicht es Ihnen, Notizen √ºber m√∂gliche Zahlen f√ºr jede Zelle zu machen.",
        helpConflicts: "<strong>Konflikte:</strong> Hebt Zellen hervor, die Zahlen enthalten, die Konflikte in ihrer Zeile, Spalte oder ihrem Block verursachen.",
        surrenderTitle: "Sind Sie sicher?",
        surrenderText: "Sie k√∂nnen dies nicht r√ºckg√§ngig machen!",
        surrenderConfirm: "Ja, aufgeben!",
        surrenderCancel: "Nein, abbrechen!",
        manualFillTitle: "F√ºllen Sie die Anfangszahlen",
        startGame: "Spiel Starten",
        manualLinkTitle: "Artikel √ºber Menschenl√∂sbares Sudoku",
        manualValidation: "Das angegebene Sudoku muss menschenl√∂sbar sein (mindestens 17 Hinweise) und den Sudoku-Regeln folgen.",
        autoFillTitle: "W√§hlen Sie die Schwierigkeit des Spiels",
        autoValidation: "Sie m√ºssen eine Schwierigkeit ausw√§hlen",
        easy: "Einfach",
        medium: "Mittel",
        hard: "Schwierig",
        expert: "Experte",
        insane: "Verr√ºckt",
        autoName: "Name",
        autoLevel: "Level des Generierten Puzzles",
        autoQuantityErrors: "Anzahl der m√∂glichen Fehler",
        autoAssistance1: "Unterst√ºtzung und Hilfe",
        autoAssistance2: "Keine Unterst√ºtzung oder Hilfe",
        autoConceptError1: "Konzeptfehler werden als Fehler gez√§hlt",
        autoConceptError2: "Konzeptfehler",
        autoConceptError3: "Konzeptfehler werden nicht als Fehler gez√§hlt",
        auto: "Automatisch",
        manual: "Manuell"
    },
    it: {
        title: "Gioco di Sudoku",
        message: "Scegli la modalit√† di riempimento del gioco",
        autoFillButton: "<i class='fas fa-magic'></i> Riempimento Automatico",
        manualFillButton: "<i class='fas fa-pencil-alt'></i> Riempimento Manuale",
        timer: "Tempo Trascorso: ",
        surrender: "Arrenditi",
        help: "Aiuto",
        close: "Chiudi",
        gameOverTitle: "‚ò†Ô∏è Fine del Gioco ‚ò†Ô∏è",
        gameOverText: "Tempo Trascorso: ",
        gameOverFillMode: "Modalit√† di Riempimento: ",
        gameOverDifficulty: "Difficolt√†: ",
        winningTitle: "üéâ Hai Vinto! üéâ",
        winningText: "Tempo Trascorso: ",
        winningFillMode: "Modalit√† di Riempimento: ",
        winningDifficulty: "Difficolt√†: ",
        restartGame: "<i class='fas fa-redo'></i> Riavvia il Gioco",
        language: "Lingua",
        selectLanguage: "Seleziona Lingua",
        helpTitle: "Aiuto Sudoku",
        helpBasicRules: "Regole di Base del Sudoku",
        rule1: "Ogni <strong>riga</strong> deve contenere i numeri da <strong>1</strong> a <strong>9</strong>, senza ripetizioni.",
        rule2: "Ogni <strong>colonna</strong> deve contenere i numeri da <strong>1</strong> a <strong>9</strong>, senza ripetizioni.",
        rule3: "Ogni <strong>blocco</strong> deve contenere i numeri da <strong>1</strong> a <strong>9</strong>, senza ripetizioni.",
        rule4: "La somma di tutti i numeri in qualsiasi <strong>riga</strong>, <strong>colonna</strong> o <strong>blocco</strong> completo √® sempre <strong>45</strong>.",
        helpAssistanceTypes: "Tipi di Assistenza",
        helpRemainingNumbersDock: "<strong>Dock dei Numeri Rimanenti:</strong> Indica i numeri richiesti nella griglia, evidenziando i numeri utilizzati. I numeri esauriti sono marcati e i numeri in eccesso diventano rossi.",
        helpNotes: "<strong>Note:</strong> Ti permette di prendere appunti sui possibili numeri per ogni cella.",
        helpConflicts: "<strong>Conflitti:</strong> Evidenzia le celle che contengono numeri che causano conflitti nella loro riga, colonna o blocco.",
        surrenderTitle: "Sei sicuro?",
        surrenderText: "Non potrai annullare questa azione!",
        surrenderConfirm: "S√¨, arrenditi!",
        surrenderCancel: "No, cancella!",
        manualFillTitle: "Riempire i numeri iniziali",
        startGame: "Inizia il Gioco",
        manualLinkTitle: "Articolo su Sudoku Risolvibile da Umani",
        manualValidation: "Il sudoku fornito deve essere risolvibile da umani (almeno 17 indizi) e deve rispettare le regole del sudoku.",
        autoFillTitle: "Scegli la difficolt√† del gioco",
        autoValidation: "Devi selezionare una difficolt√†",
        easy: "Facile",
        medium: "Medio",
        hard: "Difficile",
        expert: "Esperto",
        insane: "Pazzesco",
        autoName: "Nome",
        autoLevel: "Livello del Puzzle Generato",
        autoQuantityErrors: "Quantit√† di possibili errori da commettere",
        autoAssistance1: "Assistenza e Aiuto",
        autoAssistance2: "Nessuna Assistenza o Aiuto",
        autoConceptError1: "Gli errori di concetto sono conteggiati come errori da commettere",
        autoConceptError2: "Gli errori di concetto",
        autoConceptError3: "Gli errori di concetto non sono conteggiati come errori da commettere",
        auto: "Automatico",
        manual: "Manuale"
    },
    la: {
        title: "Ludus Sudoku",
        message: "Elige modum impletionis ludi",
        autoFillButton: "<i class='fas fa-magic'></i> Impletionem Automaticam",
        manualFillButton: "<i class='fas fa-pencil-alt'></i> Impletionem Manualem",
        timer: "Tempus Elapsum: ",
        surrender: "Dimittere",
        help: "Auxilium",
        close: "Claudere",
        gameOverTitle: "‚ò†Ô∏è Finis Ludi ‚ò†Ô∏è",
        gameOverText: "Tempus Elapsum: ",
        gameOverFillMode: "Modus Impletionis: ",
        gameOverDifficulty: "Difficultas: ",
        winningTitle: "üéâ Vicisti! üéâ",
        winningText: "Tempus Elapsum: ",
        winningFillMode: "Modus Impletionis: ",
        winningDifficulty: "Difficultas: ",
        restartGame: "<i class='fas fa-redo'></i> Restart Ludum",
        language: "Lingua",
        selectLanguage: "Selige Linguam",
        helpTitle: "Auxilium Sudoku",
        helpBasicRules: "Regulae Basicae Sudoku",
        rule1: "Omnis <strong>fila</strong> numeris ab <strong>1</strong> ad <strong>9</strong> continere debet, sine repetitione.",
        rule2: "Omnis <strong>columna</strong> numeris ab <strong>1</strong> ad <strong>9</strong> continere debet, sine repetitione.",
        rule3: "Omnis <strong>quadrum</strong> numeris ab <strong>1</strong> ad <strong>9</strong> continere debet, sine repetitione.",
        rule4: "Summa omnium numerorum in quavis <strong>fila</strong>, <strong>columna</strong>, vel <strong>quadrum</strong> est semper <strong>45</strong>.",
        helpAssistanceTypes: "Typi Auxilii",
        helpRemainingNumbersDock: "<strong>Doccus Numerorum Reliquorum:</strong> Indicat numeri requiri in tabula, numeri usi highlighting. Numeri exhauriti sunt marked et numeri superfluitates redduntur.",
        helpNotes: "<strong>Notae:</strong> Permittit notas de numeris possibilibus pro singula cellula facere.",
        helpConflicts: "<strong>Conflictus:</strong> Highlight cells quae numeros continent provocant conflictus in sua fila, columna, vel quadrum.",
        surrenderTitle: "Certe es?",
        surrenderText: "Haec non poteris revocare!",
        surrenderConfirm: "Etiam, dimittere!",
        surrenderCancel: "Non, abrogare!",
        manualFillTitle: "Implere numeros initiales",
        startGame: "Start Ludum",
        manualLinkTitle: "Articulus de Sudoku Solvendo per Humanos",
        manualValidation: "Sudoku datus debet esse solvendo per humanos (saltem 17 indicii) et debet obsequi regulis Sudoku.",
        autoFillTitle: "Elige difficultatem ludi",
        autoValidation: "Debes seligere difficultatem",
        easy: "Facilis",
        medium: "Medium",
        hard: "Difficilis",
        expert: "Expertus",
        insane: "Insanus",
        autoName: "Nomen",
        autoLevel: "Locus Puzzle Generati",
        autoQuantityErrors: "Quantitas errorum possibilibus committere",
        autoAssistance1: "Auxilium et Auxilium",
        autoAssistance2: "Nullum Auxilium nec Auxilium",
        autoConceptError1: "Errorum conceptus sunt computati ut errores committere",
        autoConceptError2: "Errorum conceptus",
        autoConceptError3: "Errorum conceptus non sunt computati ut errores committere",
        auto: "Automaticus",
        manual: "Manualis"
    }
};

let currentLanguage = 'en';

function translatePage() {
    document.title = translations[currentLanguage].title + "üé©"
    document.getElementById('title').innerText = translations[currentLanguage].title;
    document.getElementById('message').innerText = translations[currentLanguage].message;
    document.getElementById('auto-fill-button').innerHTML = translations[currentLanguage].autoFillButton;
    document.getElementById('manual-fill-button').innerHTML = translations[currentLanguage].manualFillButton;
    document.getElementById('timer').innerHTML = `<span id="time-emoji">‚è±Ô∏è</span> ${translations[currentLanguage].timer} <span id="timer-display">00:00:000</span>`;
}


// --------------------------------------- PWA!!! -------------------------------------------------------------- //
if ("serviceWorker" in navigator) {
    window.addEventListener("load", function() {
        navigator.serviceWorker
            .register("serviceWorker.js")
            .then(res => console.log("service worker registered"))
            .catch(err => console.log("service worker not registered", err))
    })
}

// ---------------------------- Global State Storage (kinda!!) ---------------------------------------------------- //
let initialNumbers = Array.from({length: 9}, () => Array(9).fill(0));
let otherNumbers = Array.from({length: 9}, () => Array(9).fill(0));
let solution = Array.from({length: 9}, () => Array(9).fill(0));
let sudokuAnimationInterval;
let startTime;
let timerInterval;
let intervalConfetti;
let notes = Array.from({length: 9}, () => Array.from({length: 9}, () => Array(9).fill(false)));
let currentNotesMenu = null;
let errorsCommitted = 0;
const maxErrors = {
    1: 5,
    2: 4,
    3: 3,
    4: 2,
    5: 1
};
const soundClick = new Audio('public/audio/click.mp3');
const soundWin = new Audio('public/audio/game-win.mp3');
const soundOver = new Audio('public/audio/game-over.mp3');
const soundStart = new Audio('public/audio/game-start.mp3');

function destroyGlobalValues(){
    initialNumbers = Array.from({length: 9}, () => Array(9).fill(0));
    otherNumbers = Array.from({length: 9}, () => Array(9).fill(0));
    startTime = undefined;

    localStorage.setItem('sudokuDifficulty', undefined);
    localStorage.setItem('sudokuGameMode', undefined);
    localStorage.setItem('sudokuGameMode', undefined);
}

// --- JUST FOR TESTING... DELETE IN THE FUTURE --- //
function printSolution(){
    console.table(solution)
}

// -------------------------------------------- Cookie ----------------------------------------------------------- //
function setCookie(name, value, days) {
    const date = new Date();
    date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
    const expires = "expires=" + date.toUTCString();
    document.cookie = name + "=" + value + ";" + expires + ";path=/";
}

function getCookie(name) {
    const nameEQ = name + "=";
    const ca = document.cookie.split(';');
    for (let i = 0; i < ca.length; i++) {
        let c = ca[i];
        while (c.charAt(0) === ' ') c = c.substring(1, c.length);
        if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
    }
    return null;
}




//----------------------------------------------- Confetti -------------------------------------------------------//
function startConfetti(){
    const duration = 10 * 1000;
    const animationEnd = Date.now() + duration;
    const defaults = { startVelocity: 30, spread: 360, ticks: 120, zIndex: 0 };

    function randomInRange(min, max) {
        return Math.random() * (max - min) + min;
    }
    intervalConfetti = setInterval(function () {
        const timeLeft = animationEnd - Date.now();

        if (timeLeft <= 0) {
            return clearInterval(intervalConfetti);
        }

        const particleCount = 30 * (timeLeft / duration);
        confetti(Object.assign({}, defaults, { particleCount, origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 } }));
        confetti(Object.assign({}, defaults, { particleCount, origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 } }));
    }, 250);
}

function stopConfetti(){
    clearInterval(intervalConfetti)
}



// -------------------------------------------------------- Timer -------------------------------------------------- //
function updateTimer() {
    const currentTime = new Date().getTime();
    const elapsedTime = currentTime - startTime;

    const minutes = Math.floor(elapsedTime / (60 * 1000));
    const seconds = Math.floor((elapsedTime % (60 * 1000)) / 1000);
    const milliseconds = elapsedTime % 1000;

    const timerDisplay = document.getElementById("timer-display");
    timerDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}:${String(milliseconds).padStart(3, '0')}`;
}

function stopTimer(){
    clearInterval(timerInterval);
}

function startTimer(){
    startTime = new Date().getTime();
    timerInterval = setInterval(updateTimer, 10);
}

// ---------------------------------- Number Dock ----------------------------------------------------------------- //
function updateNumberDock(initialNumbers) {
    const numberCounts = Array(10).fill(0);
    initialNumbers.forEach(row => {
        row.forEach(num => {
            if (num !== 0) numberCounts[num]++;
        });
    });

    const numberItems = document.querySelectorAll('#number-dock .number-item');
    numberItems.forEach(item => {
        const number = parseInt(item.getAttribute('data-number'));
        if (numberCounts[number] === 9) {
            item.classList.add('crossed');
            item.classList.remove('red');
        } else if (numberCounts[number] > 9) {
            item.classList.add('red');
            item.classList.remove('crossed');
        } else {
            item.classList.remove('crossed', 'red');
        }
    });
}

function highlightNumber(number) {
    const cells = document.querySelectorAll('.cell');
    cells.forEach(cell => {
        if (cell.textContent.toString() === number.toString()) {
            cell.classList.add('highlight');
        }
    });
}

function resetHighlight() {
    const cells = document.querySelectorAll('.cell');
    cells.forEach(cell => {
        cell.classList.remove('highlight');
    });
}

// ---------------------------------------------- Notes ---------------------------------------------------------- //
function showNotesMenu(cell, event, row, col) {
    if (currentNotesMenu) {
        currentNotesMenu.remove();
    }

    const notesMenu = document.createElement("div");
    notesMenu.classList.add("notes-menu");
    notesMenu.style.position = "fixed";

    const screenWidth = window.innerWidth;
    const screenHeight = window.innerHeight;

    let left = event.clientX;
    let top = event.clientY;

    const menuWidth = 200;
    const menuHeight = 200;

    if (left + menuWidth > screenWidth) {
        left = screenWidth - menuWidth - 10;
    }

    if (top + menuHeight > screenHeight) {
        top = screenHeight - menuHeight - 10;
    }

    notesMenu.style.left = `${left}px`;
    notesMenu.style.top = `${top}px`;

    for (let i = 1; i <= 9; i++) {
        const noteItem = document.createElement("div");
        noteItem.classList.add("note-item");
        noteItem.textContent = i;
        if (notes[row][col][i - 1]) {
            noteItem.classList.add("note-active");
        }
        noteItem.addEventListener("click", () => {
            notes[row][col][i - 1] = !notes[row][col][i - 1];
            renderNotes(cell, notes[row][col]);
            noteItem.classList.toggle("note-active");
        });
        notesMenu.appendChild(noteItem);
    }

    document.body.appendChild(notesMenu);
    currentNotesMenu = notesMenu;

    document.addEventListener("click", function closeNotesMenu(e) {
        if (!notesMenu.contains(e.target)) {
            notesMenu.remove();
            currentNotesMenu = null;
            document.removeEventListener("click", closeNotesMenu);
        }
    });
}

function renderNotes(cell, notes) {
    cell.innerHTML = "";
    const notesGrid = document.createElement("div");
    notesGrid.classList.add("notes-grid");

    notes.forEach((note, index) => {
        if (note) {
            const noteCell = document.createElement("div");
            noteCell.classList.add("note-cell");
            noteCell.textContent = index + 1;
            notesGrid.appendChild(noteCell);
        }
    });

    cell.appendChild(notesGrid);
}

function enableNotes() {
    const cells = document.querySelectorAll('.cell');
    cells.forEach(cell => {
        cell.addEventListener("contextmenu", function (event) {
            event.preventDefault();
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            showNotesMenu(cell, event, row, col);
        });

        cell.addEventListener("dblclick", function (event) {
            event.preventDefault();
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            showNotesMenu(cell, event, row, col);
        });
    });
}

function disableNotes() {
    const cells = document.querySelectorAll('.cell');
    cells.forEach(cell => {
        cell.removeEventListener("contextmenu", showNotesMenu);
        cell.removeEventListener("dblclick", showNotesMenu);
    });
}

// ----------------------------------------- Conflicts ------------------------------------------------------------ //
function highlightConflicts(numbers, difficulty) {

    const conflicts = findConflicts(numbers);

    if (difficulty === 5) {
        errorsCommitted += conflicts.length;
        if (errorsCommitted >= maxErrors[difficulty]) {
            showGameOverModal();
        }
    }
    else {
        const cells = document.querySelectorAll('.cell');
        cells.forEach(cell => cell.classList.remove('conflict'));
        conflicts.forEach(([row, col]) => {
            const cell = document.querySelector(`.cell:nth-child(${row * 9 + col + 1})`);
            if (cell) cell.classList.add('conflict');
        });
    }
}

function findConflicts(numbers) {
    const conflicts = new Set();
    const rows = Array.from({length: 9}, () => new Map());
    const cols = Array.from({length: 9}, () => new Map());
    const boxes = Array.from({length: 9}, () => new Map());

    for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
            const num = parseInt(numbers[row][col]);
            if (num !== 0) {
                const boxIndex = Math.floor(row / 3) * 3 + Math.floor(col / 3);

                if (rows[row].has(num) || cols[col].has(num) || boxes[boxIndex].has(num)) {
                    conflicts.add(`${row},${col}`);
                    if (rows[row].has(num)) {
                        rows[row].get(num).forEach(pos => conflicts.add(pos));
                    }
                    if (cols[col].has(num)) {
                        cols[col].get(num).forEach(pos => conflicts.add(pos));
                    }
                    if (boxes[boxIndex].has(num)) {
                        boxes[boxIndex].get(num).forEach(pos => conflicts.add(pos));
                    }
                }

                if (!rows[row].has(num)) rows[row].set(num, new Set());
                if (!cols[col].has(num)) cols[col].set(num, new Set());
                if (!boxes[boxIndex].has(num)) boxes[boxIndex].set(num, new Set());

                rows[row].get(num).add(`${row},${col}`);
                cols[col].get(num).add(`${row},${col}`);
                boxes[boxIndex].get(num).add(`${row},${col}`);
            }
        }
    }

    return Array.from(conflicts).map(pos => pos.split(',').map(Number));
}


// ------------------------------------ Sudoku Grid Creation ------------------------------------------------------ //
function createSudokuGrid(editable = true, grid = document.getElementById("sudoku-grid"), initial = false, numbers = initialNumbers, difficulty = 0 ) {
    grid.classList.remove('magictime', 'vanishIn');

    grid.innerHTML = "";
    if (initial) {
        grid.style.animation = 'none';
        void grid.offsetWidth;
        grid.style.animation = 'fadeIn 0.3s';
    } else if (!editable) {
        grid.style.animation = 'none';
        void grid.offsetWidth;
        grid.style.animation = 'fadeIn 1s';
    }

    for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
            const cell = document.createElement("div");
            cell.classList.add("cell");
            cell.dataset.row = row;
            cell.dataset.col = col;
            if (!editable && numbers[row][col] !== 0) {
                cell.classList.add("initial");
                cell.textContent = numbers[row][col];
            } else {
                cell.contentEditable = numbers[row][col] === 0 ? true : editable;
                cell.inputMode = 'decimal';
                cell.addEventListener("input", function () {
                    const value = this.textContent;
                    if (!/^\d$/.test(value)) {
                        this.textContent = "";
                        numbers[row][col] = 0;
                        notes[row][col] = Array(9).fill(false);
                        renderNotes(cell, notes[row][col]);
                        highlightConflicts(numbers, difficulty);
                        checkMistake(difficulty, row,  col);
                    } else {
                        numbers[row][col] = value;
                        notes[row][col] = Array(9).fill(false);
                        this.innerHTML = value;
                        highlightConflicts(numbers, difficulty);
                        checkMistake(difficulty, row,  col);
                    }
                    if (isSudokuSolved(numbers)) {
                        stopTimer();
                        showWinningModal();
                    } else {
                        updateNumberDock(numbers);
                    }
                });

                if (numbers[row][col] === 0) {
                    renderNotes(cell, notes[row][col]);
                }
            }
            grid.appendChild(cell);
        }
    }

}

// ---------------------------- Game Over ------------------------------------------------------------------------- //
function checkMistake(difficulty, row, col) {
    const currentValue = parseInt(initialNumbers[row][col]);
    if (currentValue !== 0 && currentValue !== solution[row][col]) {
        if (difficulty === 5) {
            errorsCommitted++;
        } else {

            const numbersCopy = initialNumbers.map(row => row.slice());
            numbersCopy[row][col] = currentValue;
            const conflicts = findConflicts(numbersCopy);
            const currentCellConflict = conflicts.some(([r, c]) => r === row && c === col);
            if (!currentCellConflict) {
                errorsCommitted++;
            }
        }

        if (errorsCommitted >= maxErrors[difficulty]) {
            showGameOverModal();
        }
    }
}


// --------------------------------------------------- Modals ---------------------------------------------------- //
// -------- Common Stuff ------- //
function startGame(difficulty, grid) {
    stopSudokuAnimation();
    stopTimer();
    errorsCommitted = 0;
    if (difficulty)
        generateSudoku(difficulty)

    if (grid) {
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                solution[row][col] = grid[row][col];
            }
        }
    }

    createSudokuGrid(false, document.getElementById("sudoku-grid"), false, initialNumbers, difficulty ? parseInt(difficulty) : 1);

    document.getElementById("auto-fill-button").style.display = "none";
    document.getElementById("manual-fill-button").style.display = "none";
    document.getElementById("message").style.display = "none";
    document.getElementById("timer").style.display = "block";
    document.getElementById("surrender-button").style.display = "block";

    if (difficulty !== 5) {
        document.getElementById("number-dock").style.display = "flex";
        enableNotes();
    } else {
        document.getElementById("number-dock").style.display = "none";
        disableNotes();
    }

    startTimer();
}

function detectLanguage() {
    const userLanguage = window.navigator.userLanguage || window.navigator.language;
    return userLanguage.substring(0, 2);
}

function initializeLanguage() {
    const savedLanguage = getCookie('language');
    if (savedLanguage) {
        currentLanguage = savedLanguage;
    } else {
        const detectedLanguage = detectLanguage();
        if (translations[detectedLanguage]) {
            currentLanguage = detectedLanguage;
        }
    }
    document.documentElement.lang = currentLanguage;
    translatePage();
}
// ----------------------- Help Modal --------------------- //
function showHelpModal() {
    Swal.fire({
        title: translations[currentLanguage].helpTitle,
        icon: 'info',
        html: `
            <div style="display: flex; justify-content: space-between; margin-bottom: 20px;">
                <button id="tab1" class="tab-button active">${translations[currentLanguage].helpBasicRules}</button>
                <button id="tab2" class="tab-button">${translations[currentLanguage].helpAssistanceTypes}</button>
            </div>
            <div id="tab1Content" class="tab-content" style="display: block;">
                <p>üß© <strong>${translations[currentLanguage].helpBasicRules}</strong></p>
                <ul>
                    <li>${translations[currentLanguage].rule1}</li>
                    <li>${translations[currentLanguage].rule2}</li>
                    <li>${translations[currentLanguage].rule3}</li>
                    <li>${translations[currentLanguage].rule4}</li>
                </ul>
            </div>
            <div id="tab2Content" class="tab-content" style="display: none;">
                <p>üõ†Ô∏è <strong>${translations[currentLanguage].helpAssistanceTypes}</strong></p>
                <ul>
                    <li>${translations[currentLanguage].helpRemainingNumbersDock}</li>
                    <li>${translations[currentLanguage].helpNotes}</li>
                    <li>${translations[currentLanguage].helpConflicts}</li>
                </ul>
            </div>
        `,
        preConfirm: () => {
            soundClick.play();
            navigator.vibrate(300);
            return true;
        },
        showCancelButton: false,
        confirmButtonText: `<i class="fas fa-close"></i> ${translations[currentLanguage].close}`,
        didOpen: () => {
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabContents = document.querySelectorAll('.tab-content');

            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    soundClick.play();
                    navigator.vibrate(300);
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    tabContents.forEach(content => content.style.display = 'none');

                    button.classList.add('active');
                    document.getElementById(button.id + 'Content').style.display = 'block';
                });
            });
        }
    });
}

// --------- Modal Game-Over ----------- //
function showGameOverModal() {
    const timeDisplay = document.getElementById("timer-display").textContent;
    const difficulty = localStorage.getItem('sudokuDifficulty') || 'Unknown';
    const gameMode = localStorage.getItem('sudokuGameMode') || 'Unknown';

    let difficultyStars = '';
    if (gameMode === 'auto') {
        const stars = ['‚≠ê', '‚≠ê‚≠ê', '‚≠ê‚≠ê‚≠ê', '‚≠ê‚≠ê‚≠ê‚≠ê', "‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê"];
        difficultyStars = stars[difficulty - 1] || 'Unknown';
    }

    let image = 'public/0.png';
    if(gameMode === 'auto'){
        const images = [
            'public/easy.png',
            'public/medium.png',
            'public/hard.png',
            'public/expert.png',
            'public/insane.png',
        ];
        image = images[difficulty - 1] || 'public/0.png';
    }

    Swal.fire({
        title: translations[currentLanguage].gameOverTitle,
        icon: 'error',
        html: `
            <div style="display: flex; justify-content: center; margin: 10px;">
                <div style="display: flex; justify-content: center; align-items: center; width: 175px; height: 175px; border-radius: 10px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); background: linear-gradient(135deg, #f5f7fa, #c3cfe2);">
                    <img id="difficulty-image" src="${image}" alt="Difficulty Image" style="width: 150px; height: 150px; border-radius: 5px;">
                </div>
            </div>
            <p>${translations[currentLanguage].gameOverText} <strong>${timeDisplay}</strong></p>
            <p>${translations[currentLanguage].gameOverFillMode} <strong>${gameMode === 'auto' ? translations[currentLanguage].auto : translations[currentLanguage].manual}</strong></p>
            ${gameMode === 'auto' ? `<p>${translations[currentLanguage].gameOverDifficulty} <strong>${difficultyStars}</strong></p>` : ''}
        `,
        confirmButtonText: translations[currentLanguage].restartGame,
        allowOutsideClick: false,
        allowEscapeKey: false,
        didOpen: () => {
            const restartButton = Swal.getConfirmButton();
            restartButton.addEventListener('click', () => {
                restartGame();
            });
            navigator.vibrate(3000);
            soundOver.play();
        }
    });
}

// -------- Modal Auto-Fill -------- //
function prepareModalAutoFill() {
    document.getElementById("auto-fill-button").addEventListener("click", () => {
        soundClick.play();
        navigator.vibrate(300);
        let difficulty = 0;

        Swal.fire({
            title: translations[currentLanguage].autoFillTitle,
            icon: 'question',
            html: `
                <div style="display: flex; justify-content: center; margin: 10px;">
                    <div style="display: flex; justify-content: center; align-items: center; width: 175px; height: 175px; border-radius: 10px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); background: linear-gradient(135deg, #f5f7fa, #c3cfe2);">
                        <img id="difficulty-image" src="" alt="Difficulty Image" style="display: none; width: 150px; height: 150px; border-radius: 5px;">
                    </div>
                </div>
                <div id="difficulty-info" style="margin-top: 20px; text-align: center;"></div>
                <i class="fas fa-star" id="star1" style="cursor: pointer; color: grey;"></i>
                <i class="fas fa-star" id="star2" style="cursor: pointer; color: grey;"></i>
                <i class="fas fa-star" id="star3" style="cursor: pointer; color: grey;"></i>
                <i class="fas fa-star" id="star4" style="cursor: pointer; color: grey;"></i>
                <i class="fas fa-star" id="star5" style="cursor: pointer; color: grey;"></i>
            `,
            showCancelButton: false,
            confirmButtonText: `<i class="fas fa-play"></i> ${translations[currentLanguage].startGame}`,
            preConfirm: () => {
                soundClick.play();
                navigator.vibrate(300);
                if (difficulty === 0) {
                    Swal.showValidationMessage(translations[currentLanguage].autoValidation);
                }
                return difficulty;
            },
            didOpen: () => {
                const stars = document.querySelectorAll('.fa-star');
                const difficultyImage = document.getElementById('difficulty-image');
                const difficultyInfo = document.getElementById('difficulty-info');

                const images = [
                    'public/0.png',
                    'public/easy.png',
                    'public/medium.png',
                    'public/hard.png',
                    'public/expert.png',
                    'public/insane.png',
                ];

                const difficultyNames = [
                    '',
                    translations[currentLanguage].easy,
                    translations[currentLanguage].medium,
                    translations[currentLanguage].hard,
                    translations[currentLanguage].expert,
                    translations[currentLanguage].insane,
                ];

                const errors = [
                    '',
                    '5',
                    '4',
                    '3',
                    '2',
                    '1'
                ];

                const updateDifficultyInfo = (index) => {
                    if (index === 5) {
                        difficultyInfo.innerHTML = `
                            <p>${translations[currentLanguage].autoName}: <strong>${difficultyNames[index]}</strong> üåü</p>  
                            <p>${translations[currentLanguage].autoLevel}: <strong>${difficultyNames[index-1]}</strong> üß†</p>
                            <p>${translations[currentLanguage].autoQuantityErrors}: <strong>${errors[index]}</strong> ‚ùå</p>
                            <p>${translations[currentLanguage].autoAssistance2} üö´üÜò</p>
                            <p>${translations[currentLanguage].autoConceptError1} ‚ùå</p>
                        `;
                    } else if(index === 0) {
                        difficultyInfo.innerHTML = `
                            <p>${translations[currentLanguage].autoName}: <strong>-</strong> üåü</p>
                            <p>${translations[currentLanguage].autoLevel}: <strong>-</strong> üß†üß©</p>
                            <p>${translations[currentLanguage].autoQuantityErrors}: <strong>-</strong> ‚ùå</p>
                            <p>${translations[currentLanguage].autoAssistance1} ‚úÖ‚ùå</p>
                            <p>${translations[currentLanguage].autoConceptError2} ‚úÖ‚ùå</p>
                        `;
                    } else {
                        difficultyInfo.innerHTML = `
                            <p>${translations[currentLanguage].autoName}: <strong>${difficultyNames[index]}</strong> üåü</p>
                            <p>${translations[currentLanguage].autoLevel}: <strong>${difficultyNames[index]}</strong> üß©</p>
                            <p>${translations[currentLanguage].autoQuantityErrors}: <strong>${errors[index]}</strong> ‚ùå</p>
                            <p>${translations[currentLanguage].autoAssistance1} ‚úÖ</p>
                            <p>${translations[currentLanguage].autoConceptError3} ‚úÖ</p>
                        `;
                    }
                };

                difficultyImage.src = images[0];
                difficultyImage.style.display = 'block';
                updateDifficultyInfo(0);

                stars.forEach((star, index) => {
                    star.addEventListener('click', () => {
                        soundClick.play();
                        navigator.vibrate(300);
                        difficulty = index + 1;
                        stars.forEach((s, i) => {
                            if (i <= index) {
                                s.style.color = 'gold';
                            } else {
                                s.style.color = 'grey';
                            }
                        });
                        difficultyImage.src = images[difficulty];
                        difficultyImage.style.display = 'block';
                        updateDifficultyInfo(difficulty);
                    });

                    star.addEventListener('mouseenter', () => {
                        stars.forEach((s, i) => {
                            if (i <= index) {
                                s.style.color = 'gold';
                            } else {
                                s.style.color = 'grey';
                            }
                        });
                        difficultyImage.src = images[index + 1];
                        difficultyImage.style.display = 'block';
                        updateDifficultyInfo(index + 1);
                    });

                    star.addEventListener('mouseleave', () => {
                        stars.forEach((s, i) => {
                            if (i < difficulty) {
                                s.style.color = 'gold';
                            } else {
                                s.style.color = 'grey';
                            }
                        });
                        difficultyImage.src = images[difficulty];
                        updateDifficultyInfo(difficulty);
                    });
                });
            }
        }).then((result) => {
            if (result.isConfirmed) {
                startGame(result.value);
                localStorage.setItem('sudokuDifficulty', result.value);
                localStorage.setItem('sudokuGameMode', 'auto');
                soundStart.play();
            }
        });
    });
}


// ------------ Modal Manual-Fill ----------- //
function prepareModalManualFill(){
    document.getElementById("manual-fill-button").addEventListener("click", () => {
        soundClick.play();
        navigator.vibrate(300);
        Swal.fire({
            title: translations[currentLanguage].manualFillTitle,
            icon: "question",
            html: `
            <div id="manual-window">
                <div id="manual-sudoku-grid" style="display: grid; grid-template-columns: repeat(9, 1fr); grid-template-rows: repeat(9, 1fr); gap: 2px; border: 4px solid #000; width: 100%; max-width: 500px; aspect-ratio: 1;"></div>
            </div>
        `,
            showCancelButton: false,
            footer: `<a target="_blank" href="https://www.technologyreview.com/2012/01/06/188520/mathematicians-solve-minimum-sudoku-problem/">${translations[currentLanguage].manualLinkTitle}</a>`,
            preConfirm: () => {
                soundClick.play();
                navigator.vibrate(300);
                if(!isSudokuSolvable(initialNumbers)){
                    Swal.showValidationMessage(translations[currentLanguage].manualValidation);
                    return false;
                }
                return true;
            },
            confirmButtonText: `<i class="fas fa-play"></i> ${translations[currentLanguage].startGame}`,
            didOpen: () => {
                initialNumbers = Array.from({length: 9}, () => Array(9).fill(0));
                const manualGrid = document.getElementById("manual-sudoku-grid");
                createSudokuGrid(true, manualGrid);
            }
        }).then((result) => {
            if (result.isConfirmed) {
                startGame(undefined, solveSudoku(initialNumbers.map(row => [...row])));
                localStorage.setItem('sudokuGameMode', 'manual');
                soundStart.play();
            }
        });
    });
}

// --------------------- Modal Language ----------------------------------- //
function showLanguageModal() {
    const languages = [
        { id: 'lang-en', lang: 'en', label: 'English' },
        { id: 'lang-es', lang: 'es', label: 'Espa√±ol' },
        { id: 'lang-fr', lang: 'fr', label: 'Fran√ßais' },
        { id: 'lang-pt', lang: 'pt', label: 'Portugu√™s' },
        { id: 'lang-de', lang: 'de', label: 'Deutsch' },
        { id: 'lang-it', lang: 'it', label: 'Italiano' },
        { id: 'lang-la', lang: 'la', label: 'Latin' }
    ];

    const buttonsHtml = languages.map(lang => `
        <button id="${lang.id}" class="lang-button">${lang.label}</button>
    `).join('');

    Swal.fire({
        title: translations[currentLanguage].selectLanguage,
        icon: 'question',
        html: `
            <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 10px;">
                ${buttonsHtml}
            </div>
        `,
        showConfirmButton: false,
        showCancelButton: false,
        didOpen: () => {
            languages.forEach(lang => {
                document.getElementById(lang.id).addEventListener('click', () => {
                    handleLanguageChange(lang.lang);
                });
            });
        }
    });
}

function handleLanguageChange(lang) {
    soundClick.play();
    navigator.vibrate(300);
    currentLanguage = lang;
    setCookie('language', lang, 365);
    document.documentElement.lang = lang;
    translatePage();
    Swal.close();
}


// ----------------- Modal Winning-Congrats!!! -------------------------- //
function showWinningModal() {
    const timeDisplay = document.getElementById("timer-display").textContent;
    const difficulty = localStorage.getItem('sudokuDifficulty') || 'Unknown';
    const gameMode = localStorage.getItem('sudokuGameMode') || 'Unknown';

    let difficultyStars = '';
    if (gameMode === 'auto') {
        const stars = ['‚≠ê', '‚≠ê‚≠ê', '‚≠ê‚≠ê‚≠ê', '‚≠ê‚≠ê‚≠ê‚≠ê', "‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê"];
        difficultyStars = stars[difficulty - 1] || 'Unknown';
    }

    let image = 'public/0.png';
    if(gameMode === 'auto'){
        const images = [
            'public/easy.png',
            'public/medium.png',
            'public/hard.png',
            'public/expert.png',
            'public/insane.png',
        ];
        image = images[difficulty - 1] || 'public/0.png';
    }

    Swal.fire({
        title: translations[currentLanguage].winningTitle,
        icon: 'success',
        html: `
            <div style="display: flex; justify-content: center; margin: 10px;">
                <div style="display: flex; justify-content: center; align-items: center; width: 175px; height: 175px; border-radius: 10px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); background: linear-gradient(135deg, #f5f7fa, #c3cfe2);">
                    <img id="difficulty-image" src="${image}" alt="Difficulty Image" style="width: 150px; height: 150px; border-radius: 5px;">
                </div>
            </div>
            <p>${translations[currentLanguage].winningText} <strong>${timeDisplay}</strong></p>
            <p>${translations[currentLanguage].winningFillMode} <strong>${gameMode === 'auto' ? translations[currentLanguage].auto : translations[currentLanguage].manual}</strong></p>
            ${gameMode === 'auto' ? `<p>${translations[currentLanguage].winningDifficulty} <strong>${difficultyStars}</strong></p>` : ''}
        `,
        confirmButtonText: translations[currentLanguage].restartGame,
        allowOutsideClick: false,
        allowEscapeKey: false,
        didOpen: () => {
            const restartButton = Swal.getConfirmButton();
            restartButton.addEventListener('click', () => {
                soundClick.play();
                navigator.vibrate(300);
                restartGame();
            });
            startConfetti();
            navigator.vibrate(3000);
            soundWin.play();
        }
    });
}


// -------------------------------------- Sudoku Initial Animation --------------------------------------------- //
function generateInitialSudoku() {
    otherNumbers = Array.from({length: 9}, () => Array(9).fill(0));
    generateSudoku(3, otherNumbers);
    createSudokuGrid(false, document.getElementById("sudoku-grid"), true, otherNumbers);
}

function startSudokuAnimation() {
    sudokuAnimationInterval = setInterval(() => {
        generateInitialSudoku()
    }, 2000);
}

function stopSudokuAnimation(){
    clearInterval(sudokuAnimationInterval);
}


// -------------------------------------- Restart Game ---------------------------------------------------------- //
function restartGame(){
    soundClick.play();
    navigator.vibrate(300);
    destroyGlobalValues();

    document.getElementById("auto-fill-button").style.display = "block";
    document.getElementById("manual-fill-button").style.display = "block";
    document.getElementById("message").style.display = "block";
    document.getElementById("timer").style.display = "none";
    document.getElementById("number-dock").style.display = "none";
    document.getElementById("surrender-button").style.display = "none";

    stopConfetti();
    stopSudokuAnimation();
    stopTimer();

    generateInitialSudoku();
    startSudokuAnimation();

    notes = Array.from({length: 9}, () => Array.from({length: 9}, () => Array(9).fill(false)));
}

// ------------------------------------------ Initialization ---------------------------------------------------- //
document.addEventListener("DOMContentLoaded", () => {
    const numberItems = document.querySelectorAll('#number-dock .number-item');

    numberItems.forEach(item => {
        const number = parseInt(item.getAttribute('data-number'));
        item.addEventListener('mouseenter', () => highlightNumber(number));
        item.addEventListener('mouseleave', () => resetHighlight());
        item.addEventListener('touchstart', () => highlightNumber(number));
        item.addEventListener('touchend', () => resetHighlight());
    });

    prepareModalManualFill();
    prepareModalAutoFill();
    generateInitialSudoku();
    startSudokuAnimation();

    document.getElementById('help-button').addEventListener('click', () => {showHelpModal(); soundClick.play();});
    document.getElementById('surrender-button').addEventListener('click', () => {
        soundClick.play();
        navigator.vibrate(300);
        showGameOverModal();
    });

    // --------------------------------------- Surrender Button Functionality ------------------------------------------- //
    document.getElementById('surrender-button').addEventListener('click', () => {
        soundClick.play();
        navigator.vibrate(300);
        Swal.fire({
            title: translations[currentLanguage].surrenderTitle,
            text: translations[currentLanguage].surrenderText,
            icon: 'warning',
            showCancelButton: true,
            confirmButtonColor: '#3085d6',
            cancelButtonColor: '#d33',
            confirmButtonText: `<i class="fas fa-flag"></i> ${translations[currentLanguage].surrenderConfirm}`,
            cancelButtonText: `<i class="fas fa-times"></i> ${translations[currentLanguage].surrenderCancel}`
        }).then((result) => {
            if (result.isConfirmed) {
                soundClick.play();
                navigator.vibrate(300);
                showGameOverModal();
            }
        });
    });

    const buttonGroup = document.getElementById('button-group');
    const hintIndicator = document.getElementById('hint-indicator');

    hintIndicator.addEventListener('click', () => {
        navigator.vibrate(300);
        buttonGroup.classList.toggle('visible');
        hintIndicator.classList.toggle('hidden');
    });

    document.addEventListener('click', (event) => {
        if (!buttonGroup.contains(event.target) && event.target !== hintIndicator) {
            buttonGroup.classList.remove('visible');
            hintIndicator.classList.remove('hidden');
        }
    });


    initializeLanguage();
    document.getElementById('language-button').addEventListener('click', () => {
        soundClick.play();
        navigator.vibrate(300);
        showLanguageModal();
    });
});
